#!/bin/bash -e
#
# SPDX-License-Identifier: Apache-2.0
#

set -o errexit
set -o pipefail
set -o nounset

# Version control
VERSION=0.1
CENTOS_VERSION=7.3

# StarlingX docker image customization
USER="${USER:-$(id -un)}"
MYUNAME="${MYUNAME:-builder}"
STX_CONTAINER_TAG="starlingx/${USER}-stx-builder:${CENTOS_VERSION}"
STX_CONTAINER_NAME="${USER}-centos-builder-${$}"

# StarlingX docker container execution customization
WORKSPACE_NAME="starlingx"
WORK_DIRECTORY="${PWD}/${WORKSPACE_NAME}"
GUEST_LOCALDISK="localdisk"
PROJECT="${PROJECT:-test}"
PROJECT_PATH="/${GUEST_LOCALDISK}/designer/${MYUNAME}/${PROJECT}"
REPO_PATH="${WORK_DIRECTORY}/repositories"
DISTRO_NAME="CentOS"
MIRROR_DIRECTORY="${WORK_DIRECTORY}/mirror"
STX_TOOLS_REPO="git://git.openstack.org/openstack/stx-tools"
WORK_DIRECTORY_FLAG="false"
BUILD_MIRROR_FLAG="false"
BUILD_ISO_FLAG="false"
UPDATE_FLAG="false"
MIRROR_DIRECTORY_FLAG="false"
REPO_PATH_FLAG="false"
BUILD_ALL_FLAG="false"
REGENERATE_MIRROR_FLAG="false"
INTERACTIVE_MODE_FLAG="false"
STARLINGX_RELEASE_NAME="r1"
OPENSTACK_RELEASE="pike"
BUILDRC_FILE="/etc/stxb/buildrc"
LOCAL_STX_SOURCE_PATH="${HOME}/.stxb"
LOCAL_STX_SOURCE_FILE="${LOCAL_STX_SOURCE_PATH}/.stxbrc"
LOCAL_WORK_DIRECTORY_SOURCE_FILE="${WORK_DIRECTORY}/.stbrc"

# Customization of this tool
LOG_PATH="${WORK_DIRECTORY}/log"
LOG_FILE="${LOG_PATH}/stx-$(date +%s).log"
SHA_PATH="${WORK_DIRECTORY}/sha"
STABLE_LIST_SHA256SUM_FILE="${SHA_PATH}/stable-mirror-list-files.txt"
CURRENT_LIST_SHA256SUM_FILE="${SHA_PATH}/current-mirror-list-files.txt"

# Run local stx sources to override default values
if [ ! -d "${LOCAL_STX_SOURCE_PATH}" ]; then
    mkdir -p "${LOCAL_STX_SOURCE_PATH}"
    touch "${LOCAL_STX_SOURCE_FILE}"
elif [ -f "${LOCAL_STX_SOURCE_FILE}" ]; then
    source "${LOCAL_STX_SOURCE_FILE}"
fi
if [ -e "${LOCAL_WORK_DIRECTORY_SOURCE_FILE}" ]; then
    source "${LOCAL_WORK_DIRECTORY_SOURCE_FILE}"
fi

function build_mirror_help()
{
cat <<EOF
usage: $0 build mirror [OPTIONS] ...
Description:
    Build StarlingX mirror.

Optional arguments:
    -c,    delete previous  workspace, mirror and docker image.
    -h,    show this help menu.
    -n,    set mirror name.
    -p,    set mirror_path.
    -u,    update repositories and mirror
EOF
}

function build_mirror()
{
    declare OPTIND

    while getopts "p:hw:cu" opt; do
        case "${opt}" in
        c)
           CLEAN_FLAG="true"
        ;;
        h)
            build_mirror_help
            exit 0
        ;;
        p)
            MIRROR_DIRECTORY="${OPTARG}"
            MIRROR_DIRECTORY_FLAG="true"
        ;;
        u)
            UPDATE_FLAG="true"
        ;;
        w)
            WORK_DIRECTORY="${OPTARG}"
            WORK_DIRECTORY_FLAG="true"
        ;;
        *)
            exit 1
        ;;
        esac
    done
    shift $((OPTIND-1))

    if [ "${WORK_DIRECTORY_FLAG:-false}" = "true" ]; then
        update_configs
    fi
    if [ ! -d "${LOG_PATH}" ]; then
        mkdir -p "${LOG_PATH}"
    fi
   build_mirror_command |& tee "$LOG_FILE"
}

function build_mirror_command()
{
        init_work_directory
        check_mirror_list_sha
        if [ "${REGENERATE_MIRROR_FLAG}" = "true" ]; then
            if [ ${UPDATE_FLAG:-false} = "true" ]; then
                build_docker_image
                docker_run_mirror
            else
                print -i "Skipping, changes detected but update opt is not set"
            fi
        else
            print -i "Skipping build mirror"
        fi
  }

function update_configs()
{
    if [ "${WORK_DIRECTORY:0:1}" != "/" ]; then
        WORK_DIRECTORY="${PWD}/${WORK_DIRECTORY}"
    fi
    LOG_PATH="${WORK_DIRECTORY}/log"
    LOG_FILE="${LOG_PATH}/stx-$(date +%s).log"
    LOG_FILE="${LOG_PATH}/stx-$(date +%s).log"
    SHA_PATH="${WORK_DIRECTORY}/sha"
    STABLE_LIST_SHA256SUM_FILE="${SHA_PATH}/stable-mirror-list-files.txt"
    CURRENT_LIST_SHA256SUM_FILE="${SHA_PATH}/current-mirror-list-files.txt"
    if [ "${MIRROR_DIRECTORY_FLAG:-false}" = "false" ]; then
        MIRROR_DIRECTORY="${WORK_DIRECTORY}/mirror"
    fi
    if [ "${REPO_PATH_FLAG:-false}" = "false" ]; then
        REPO_PATH="${WORK_DIRECTORY}/repositories"
    fi
 }

function init_work_directory()
{
    local project_path="${WORK_DIRECTORY}/${PROJECT_PATH}"
    local repo_path="${project_path}/.repo"

    if [ "${CLEAN_FLAG:-false}" = "true" ]; then
        if [ "${BUILD_ALL_FLAG:-false}" = "true" ]; then
            rm -rf "${project_path}"
            rm -rf "${MIRROR_DIRECTORY}"
            clean_docker_image
        else
            if [ "${BUILD_ISO_FLAG:-false}" = "true" ]; then
                rm -rf "${project_path}"
            elif [ "${BUILD_MIRROR_FLAG:-false}" = "true" ]; then
                rm -rf "${MIRROR_DIRECTORY}"
            elif [ "${BUILD_DOCKER_IMAGE_FLAG:-false}" = "true" ]; then
                clean_docker_image
            fi
        fi
    fi
    if [ ! -d "${WORK_DIRECTORY}" ]; then
        print -i "Creating working directory"
        mkdir -p "${project_path}"
    elif [ ! -d "${project_path}" ]; then
        print -i "Creating project directory"
        mkdir -p "${project_path}"
    fi
    if [ ! -d "${REPO_PATH}" ]; then
        mkdir -p "${REPO_PATH}"
    fi
    print -i "Using work directory: ${WORK_DIRECTORY}"
    if [ ! -d "${SHA_PATH}" ]; then
        mkdir -p "${SHA_PATH}"
    fi
    if [ ! -d "${MIRROR_DIRECTORY}" ]; then
        print -i "Creating mirror path directory"
        mkdir -p "${MIRROR_DIRECTORY}"
    else
        print -i "Using existing mirror path"
    fi
    if [ "${UPDATE_FLAG:-false}" = "true" ]; then
        if [ ! -f "${repo_path}" ]; then
            if [ "${BUILD_MIRROR_FLAG:-false}" = "true" ]; then
                stx_tools_path="${REPO_PATH}/${STX_TOOLS_REPO/*\//}"
                if [ -d "$stx_tools_path" ]; then
                    print -i "Git pulling stx-tools repo from ${stx_tools_path}"
                    git pull "$stx_tools_path"
                else
                    print -i "Cloning stx-tools repository into workspace"
                    git clone "$STX_TOOLS_REPO" "$stx_tools_path"
                fi
            else
                print -i "Cloning starlingx repo manifests into workspace"
                docker_run_repo_sync
            fi
        else
            print -i "Updating repositories using repo sync"
            docker_run_repo_sync
        fi
    else
        print -i "Skipping cloning repositories, update opt is not set"
    fi
}

function docker_run_builder()
{
    local id
    local container_mirror_path="/import/mirrors/CentOS/stx-r1/CentOS/pike/"
    local buildrc_container_path="/home/${MYUNAME}/buildrc"
    local cmd_generate_cgcs_centos_repo=""
    local cmd_generate_cgcs_tis_repo=""
    local cmd_populate_downloads=""

    if [ "${REGENERATE_MIRROR_FLAG:-}" = "true" ]; then
        print -i "The next scripts will be executed in the builder"
        print -t "generate-cgcs-centos-repo.sh"
        print -t "generate-cgcs-tis-repo"
        print -t "populate-downloads.sh"
        cmd_generate_cgcs_centos_repo="generate-cgcs-centos-repo.sh ${container_mirror_path} &&"
        cmd_generate_cgcs_tis_repo="generate-cgcs-tis-repo &&"
        cmd_populate_downloads="populate_downloads.sh $container_mirror_path &&"
    else
        print -i "No changes detected skipping"
    fi
    # This is the group of commands that run inside the
    # container in order ti build the packages and create the ISO.
    local cmd_line="
        ${cmd_generate_cgcs_centos_repo} \
        ${cmd_populate_downloads} \
        build-pkgs && \
        ${cmd_generate_cgcs_tis_repo} \
        build-iso"

    if docker run -it --rm \
        --name "${STX_CONTAINER_NAME}" \
        --detach \
        --user="${MYUNAME}" \
        -v "${WORK_DIRECTORY}/${GUEST_LOCALDISK}:/${GUEST_LOCALDISK}" \
        -v "${REPO_PATH}:/${PROJECT_PATH}" \
        -v "${MIRROR_DIRECTORY}:/import/mirrors:ro" \
        -v "${BUILDRC_FILE}:${buildrc_container_path}:ro" \
        -v "/sys/fs/cgroup:/sys/fs/cgroup:ro" \
        -e "container=docker" \
        -e "MYUNAME=${MYUNAME}" \
        -w "${PROJECT_PATH}" \
        --privileged=true \
        --security-opt seccomp=unconfined \
        "${STX_CONTAINER_TAG}"; then
        id=$(docker ps | awk '/'"${STX_CONTAINER_NAME}"'/ {print $1}')
        print -i "Container ${STX_CONTAINER_NAME} runs with id $id"
    else
        print -e "Container ${STX_CONTAINER_NAME} failed"
    fi
    if docker exec -it \
        "${STX_CONTAINER_NAME}" \
        bash -c -l  "${cmd_line}"; then
        print -s "Iso has been generated"
    else
        if [ "${INTERACTIVE_MODE_FLAG:-false}" = "true" ]; then
            print -e "Iso image couldn't be generated"
            print -t "Do you want to debug the container \
                ${STX_CONTAINER_NAME} with id ${id} [Y/n]"
            read -r question_option
            if [[ "${question_option:-Y}" = "^[y-Y]$" ]]; then
                print -i "Debugging ${STX_CONTAINER_NAME} with id ${id}"
                docker exec -it "${STX_CONTAINER_TAG}" bash
            fi
        else
            kill_container "${id}"
            print -e "Iso image couldn't be generated"
        fi
    fi
    kill_container "${id}"
}

function kill_container()
{
    local id="${1}"
    if docker kill "${id}"; then
        print -i "Killed container ${STX_CONTAINER_NAME} with id ${id}"
    else
        print -e "Killing container ${STX_CONTAINER_NAME} with id ${id}"
    fi
}

function docker_run_repo_sync()
{
    local id
    local repo_threads="8"
    local cmd_line="  sleep .7; \
                if [ ! -d '.repo' ]; then \
                    repo init -u https://git.starlingx.io/stx-manifest.git \
                    --no-clone-bundle; \
                fi
                repo sync --no-clone-bundle -j${repo_threads} --force-sync"

    if docker run -it --rm \
        --user="${MYUNAME}" \
        -v "${REPO_PATH}:/${GUEST_LOCALDISK}" \
        -w "/${GUEST_LOCALDISK}" \
        "${STX_CONTAINER_TAG}" \
        bash -c "${cmd_line}"; then
        id=$(docker ps | awk '/'"${STX_CONTAINER_NAME}"'/ {print $1}')
        print -i "Container ${STX_CONTAINER_NAME} runs with id $id"
    else
        print -e "Container ${STX_CONTAINER_NAME} failed"
    fi
}

function check_mirror_list_sha()
{
    local mirror_directory="centos-mirror-tools"
    local repository_name="${STX_TOOLS_REPO/*\//}"
    local mirror_list_path="${REPO_PATH}/${repository_name}/${mirror_directory}"
    local list_file_prefix="${mirror_list_path}/"
    local current_list_sha256sum
    local stable_list_sha256sum

    if [ -d "${mirror_list_path}" ]; then
        current_list_sha256sum=$(cat "${list_file_prefix}"*.lst | sha256sum)
    else
        print -e "No mirror list found"
        REGENERATE_MIRROR_FLAG="false"
        return 0
    fi
    printf "%s\\n" "${current_list_sha256sum}" > "${CURRENT_LIST_SHA256SUM_FILE}"

    if [ -f "${STABLE_LIST_SHA256SUM_FILE}" ]; then
        stable_list_sha256sum=$(cat "${STABLE_LIST_SHA256SUM_FILE}")
        if [ "${current_list_sha256sum}" = "${stable_list_sha256sum}" ]; then
            print -i "No changes on lists were detected"
            REGENERATE_MIRROR_FLAG="false"
            return 0
        else
            print -i "New changes on lists were detected"
        fi
    else
        print -i "No stable mirror detected"
    fi
    REGENERATE_MIRROR_FLAG="true"
}

function docker_run_mirror()
{
    local id
    local script="stx-tools/centos-mirror-tools/download_mirror.sh"
    local script_path="${REPO_PATH}/${script%/*}"
    local mirror_path="$script_path/output/stx-${STARLINGX_RELEASE_NAME}"
    local distro_mirror_path="${MIRROR_DIRECTORY}/${DISTRO_NAME}"
    local tis_installer_mirror_path="${MIRROR_DIRECTORY}/${DISTRO_NAME}/tis-installer"
    local binary_mirror_path="${mirror_path}/${DISTRO_NAME}/${OPENSTACK_RELEASE}/Binary"
    local version="0.2"
    local local_mirror="/import/mirror"

    if docker run -it  --rm \
        --name "${STX_CONTAINER_NAME}" \
        -v "${script_path}:/${GUEST_LOCALDISK}" \
        -v "${MIRROR_DIRECTORY}:/${local_mirror}" \
        -w "/${GUEST_LOCALDISK}" \
        "${STX_CONTAINER_TAG}" \
        bash -c "${script/*\//\./}"; then
        id=$(docker ps | awk '/'"${STX_CONTAINER_NAME}"'/ {print $1}')
        print -i "Container ${STX_CONTAINER_NAME} finished with id $id"
        print -i "Setting mirror lists sha as stable"
        cp "${CURRENT_LIST_SHA256SUM_FILE}" "${STABLE_LIST_SHA256SUM_FILE}"
    else
        print -e "Container ${STX_CONTAINER_NAME} failed"
    fi
    if [ ! -d "${MIRROR_DIRECTORY}/${DISTRO_NAME}" ]; then
        mkdir -p "${distro_mirror_path}"
    fi
    if [ ! -d "${tis_installer_mirror_path}" ]; then
        mkdir -p "${tis_installer_mirror_path}"
    fi
    cp -rf "${mirror_path}/" "${MIRROR_DIRECTORY}/${DISTRO_NAME}"
    cp -f \
        "${binary_mirror_path}/images/pxeboot/initrd.img" \
        "${tis_installer_mirror_path}/initrd.img-stx-${version}"
    cp -f \
        "${binary_mirror_path}/images/pxeboot/vmlinuz" \
        "${tis_installer_mirror_path}/vmlinuz-stx-${version}"
    cp -f \
        "${binary_mirror_path}/LiveOS/squashfs.img" \
        "${tis_installer_mirror_path}/squashfs.img-stx-${version}"
}

function print()
{
    declare OPTIND
    local message
    local message_type
    local clean_color
    local time_stamp
    local color
    time_stamp="$(date -u +'%Y%m%dT%H%M%SZ')"
    local ret_code="0"
    local stderr_flag="false"
    while getopts "i:w:e:s:t:" opt; do
        case "${opt}" in
        i)
            message_type="[ INFO ]"
            message="${OPTARG}"
            color="\\e[1;30m"
            ;;
        w)
            message_type="[ WARNING ]"
            message="${OPTARG}"
            color="\\e[1;33m"
            stderr_flag="true"
            ;;
        e)
            message_type="[ ERROR ]"
            message="${OPTARG}"
            color="\\e[0;31m"
            stderr_flag="true"
            ret_code="1"
            ;;
        s)
            message_type="[ SUCCESS ]"
            message="${OPTARG}"
            color="\\e[0;32m"
            ;;
        t)
            message_type=""
            message="${OPTARG}"
            color=""
            ;;
        *)
            return 1
            ;;
        esac
    done
    if [[ "${TERM:-none}" = *"256color" ]]; then
        clean_color="\\033[0m"
    else
        clean_color=""
        color=""
    fi

    if [ ${stderr_flag:-false} = "true" ]; then
        printf "%-20s%b%-16s%b%s\\n"  "${time_stamp}" "${color}" \
            "${message_type}" "${clean_color}" "${message}">&2
    else
        printf "%-20s%b%-16s%b%s\\n" "${time_stamp}" "${color}" \
            "${message_type}" "${clean_color}" "${message}"
    fi
    return "${ret_code}"
}

function check_docker_image()
{
    if docker images | grep "${STX_CONTAINER_TAG/:*/}"; then
        print  -i "${STX_CONTAINER_TAG} image found"
        return 0
    else
        print -w "Previous ${STX_CONTAINER_TAG} image not found"
        return 1
    fi
}

function build_docker_image_help()
{
cat <<EOF
usage: $0 build docker-image [OPTIONS] ...
Description:
    Build StarlingX docker-image

Optional arguments:
    -c,    delete previous workspace, mirror and docker image.
    -h,    show this help menu.
EOF
}


function build_docker_image()
{
    declare OPTIND
    local myuname="builder"

    while getopts "ch" opt; do
        case "${opt}" in
        c)
            CLEAN_FLAG="true"
        ;;
        h)
            build_docker_image_help
            exit 0
        ;;
        *)
            exit 1
        ;;
        esac
    done
    shift $((OPTIND-1))
    build_docker_image_command |& tee "$LOG_FILE"
}

function build_docker_image_command()
{
    if [ "${CLEAN_FLAG:-false}" = "true" ]; then
        clean_docker_image
    else
        if check_docker_image; then
            print -i "Previous docker image ${STX_CONTAINER_TAG} found"
            return 0
        fi
    fi
    print -i "Building ${STX_CONTAINER_TAG} docker image"
    if docker build \
        --build-arg "MYUID=$(id -u)" \
        --build-arg "MYUNAME=${myuname}" \
        --ulimit core=0 \
        --network host \
        -t "${STX_CONTAINER_TAG}" \
        .; then
        print -s "Docker ${STX_CONTAINER_TAG} built"
    else
        print -e "Error building ${STX_CONTAINER_TAG}"
    fi
}

function clean_docker_image()
{
    if docker images | grep "${STX_CONTAINER_TAG/:*/}"; then
        print -i "Cleaning environment"
        if docker ps | grep " ${STX_CONTAINER_TAG} "; then
            for id in \
                $(docker ps | awk '/'" ${STX_CONTAINER_NAME} "'/ {print $1}'); do
                if docker rm -f "$id"; then
                    print -i "Container with id $id was deleted"
                else
                    print -e "Error deleting container with id $id"
                fi
            done
        fi
   else
        print -i "No previous docker image ${STX_CONTAINER_TAG} found"
        return 0
    fi

    if docker image rm "${STX_CONTAINER_TAG}" -f; then
        print -s "The ${STX_CONTAINER_TAG} docker image was deleted"
    else
        print -e "The ${STX_CONTAINER_TAG} can't be deleted"
    fi
}

function list_log()
{
    if [ ! -d "$LOG_PATH" ]; then
        print -i "SatrlingX build log files no found"
    else
        find  "$LOG_PATH" -type f -name "*.log" -exec basename {} \;| sort -n
    fi
}

function view_log_help()
{
cat <<EOF
usage: $0 build log [OPTIONS] ...
Description:
    Show StarlingX logs.

Optional arguments:
    -h,    show this help menu.
    -n     show specified log name.
    -l     list logs.
    -p,    set log path.
EOF
}

function view_log()
{
    local OPTIND
    local log_name

    while getopts "ln:p:h" opt; do
        case "${opt}" in
        l)
            list_log
            return "$?"
        ;;
        n)
            log_name=${OPTARG}
        ;;
        p)
            LOG_PATH=${OPTARG}
        ;;
        h)
            view_log_help
        ;;
        *)
            exit 1
        ;;
        esac
    done
    shift $((OPTIND-1))
    log_name="$(list_log | tail -n 1)"
   if [ -z "${log_name}" ]; then
        print -i "No logs found on ${LOG_PATH}"
    else
        less "${LOG_PATH}/${log_name}"
    fi
}

function build_iso_help()
{
cat <<EOF
usage: $0 build iso [OPTIONS] ...
Description:
    Build StarlingX ISO

Optional arguments:
    -c,    delete previous  workspace, mirror and docker image.
    -h,    show this help menu.
    -i,    enable y/n decisions.
    -n,    set mirror name.
    -p,    set mirror_path.
    -r,    set repositories directory.
    -u,    update repositories and mirror
    -w,    set work_directory.
EOF
}

function build_iso()
{
    local OPTIND

    while getopts "p:w:hciur" opt; do
        case ${opt} in
        c)
            CLEAN_FLAG=""
        ;;
        h)
            build_iso_help
            exit 0
        ;;
        i)
            INTERACTIVE_MODE_FLAG="true"
        ;;
        p)
            MIRROR_DIRECTORY="${OPTARG}"
            MIRROR_DIRECTORY_FLAG="true"
        ;;
        r)
            REPO_PATH="${OPTARG}"
            REPO_PATH_FLAG="true"
        ;;
        u)
            UPDATE_FLAG="true"
        ;;
        w)
            WORK_DIRECTORY="${OPTARG}"
            WORK_DIRECTORY_FLAG="true"
        ;;
        *)
            exit 1
        ;;
        esac
    done
    shift $((OPTIND-1))

    if [ "${WORK_DIRECTORY_FLAG:-false}" = "true" ]; then
        update_configs
    fi
    if [ ! -d "${LOG_PATH}" ]; then
        mkdir -p "${LOG_PATH}"
    fi
    build_iso_command |& tee "$LOG_FILE"
}

function build_iso_command()
{
    build_docker_image_command
    build_mirror_command
    docker_run_builder
}

function build_help()
{
cat <<EOF
usage: $0 build COMMAND [options] ...
Description:
    This tool allows to build and debug an
    StarlingX ISO image.

List of Main Commands:
    docker-image,    build docker image.
    help,            show this help menu.
    iso,             build iso.
    mirror,          build mirror.
EOF
}

function build()
{
    if [ "$#" -eq 0 ]; then
        build_help
        exit 1
    fi
    command=$1
    shift
    case $command in
    docker-image)
        BUILD_DOCKER_IMAGE_FLAG="true"
        build_docker_image "$@"
        ;;
    help)
        build_help
    ;;
    iso)
        BUILD_ISO_FLAG="true"
        build_iso "$@"
    ;;
    mirror)
        BUILD_MIRROR_FLAG="true"
        build_mirror "$@"
    ;;
   *)
        if [ -n "$command" ]; then
            print -e "Unknown command: $command"
        fi
    ;;
    esac
}

function general_help()
{
cat <<EOF
usage: $0 COMMAND [options] ...
Description:
    This tool allows to build and debug an
    StarlingX ISO image.

List of Main Commands:
    build,       build starlingx.
    help,        show this help menu.
    view-log,    show log.
    version,     show the version of this script.
EOF
}

function main()
{
    if [ "$#" -eq 0 ]; then
        general_help
        exit 1
    fi

    command=$1
    shift
    case $command in
    build)
        build "${@}"
        print -i "Total time: $SECONDS seconds"
    ;;
    help)
        general_help
    ;;
    view-log)
        view_log "${@}"
    ;;
    version)
        print -i "StarlingX tool version: $VERSION"
        exit 0
    ;;
    *)
        if [ -n "$command" ]; then
            print -e "Unknown command: $command"
        fi
    ;;
    esac
}

main "$@"
